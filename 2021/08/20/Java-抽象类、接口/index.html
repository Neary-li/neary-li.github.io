<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Neary Li">




    <meta name="keywords" content="IT">


<title>抽象类、接口 | Neary-Li&#39;s Blog</title>



    <link rel="icon" href="../../../../favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="../../../../css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="../../../../js/script.js"></script>
    
    <script src="../../../../js/tocbot.min.js"></script>
    



    
    
        
    



<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Neary&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="../../../../archives">Posts</a>
                
                    <a class="menu-item" href="../../../../category">Categories</a>
                
                    <a class="menu-item" href="../../../../tag">Tags</a>
                
                    <a class="menu-item" href="../../../../about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Neary&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="../../../../archives">Posts</a>
                
                    <a class="menu-item" href="../../../../category">Categories</a>
                
                    <a class="menu-item" href="../../../../tag">Tags</a>
                
                    <a class="menu-item" href="../../../../about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">抽象类、接口</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Neary Li</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">August 20, 2021&nbsp;&nbsp;22:25:15</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="../../../../categories/Java/">Java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h3 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1. 抽象类"></a>1. 抽象类</h3><p>:leaves:方法 \epsilon 类</p>
<ol>
<li><p><span color="red">abstract修饰符可以用来修饰方法，也可以修饰类，如果修饰方法，那么该方法就是抽象方法；如果修饰类，那么该类就是抽象类。</span></p>
</li>
<li><p>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。</p>
</li>
<li><p><strong>抽象类，不能使用 new 关键字类床架你对象，它是用来让子类继承的。</strong></p>
</li>
<li><p><strong>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。</strong></p>
</li>
<li><p>子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。</p>
</li>
</ol>
<p><code>Action.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入 abstract 关键字 Action 变成了 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="comment">// abstract方法， 抽象方法，只有抽象的名字，没有方法的实现！！！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.不能new这个抽象类，只能靠子类去实现它：约束！</span></span><br><span class="line">    <span class="comment">// 2.抽象类中可以写普通的方法</span></span><br><span class="line">    <span class="comment">// 3.抽象方法必须在抽象类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>A.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类的抽象方法都有它的子类实现，除非子类也是抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am studying!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考题</strong>：</p>
<ol>
<li><p>抽象类存在构造器吗？</p>
<ul>
<li>存在，即使你没有提供任何构造函数，编译器将为抽象类添加默认的无参数的构造函数，没有的话你的子类将无法编译，因为在任何构造函数中的第一条语句隐式调用<code>super()</code>。</li>
</ul>
</li>
<li><p>抽象类存在的意义是什么？</p>
<ul>
<li><p>在现实中确实存在有些父类中的方法确实没有必要写，因为各个子类中的这个方法肯定会有不同，所以没有必要再父类里写。</p>
</li>
<li><p>而写成抽象类，这样别人看到你的代码，或你看到别人的代码，你就会注意抽象方法，而知道这个方法是在子类中实现的，所以，有个提示作用。</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">普通类：只有具体的实现</span><br><span class="line">抽象类：具体实现和规范（抽象方法）都有！</span><br><span class="line">接口：只有规范！</span><br><span class="line"><span class="comment">/* 自己无法写方法，约束和实现分离：面向接口编程 */</span></span><br></pre></td></tr></table></figure>

<ol>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是……则必须能……”的思想。<ul>
<li>如果你是天使，这必须能飞；如果你是好人，这必须爱护人民……</li>
</ul>
</li>
<li>接口的本质是七月，就像法律一样，制定好后大家必须遵守。</li>
<li>OO 的精髓，是对对象的抽象，最能体现这样这一点的就是接口。为什么我们讨论设计模式都只针对了具备了抽象能力的语言（<code>C++，Java，C#</code>等），就是因为设计模式说研究的实际上就是如何合理的去抽象。</li>
<li><strong>声明</strong></li>
<li><strong>类的关键字是<code>class</code>, 声明接口的关键字是<code>interface</code></strong></li>
<li>作用<ul>
<li>约束</li>
<li>定义一些方法，让不同的人去实现</li>
<li>方法 ：<code>public abstract</code><ul>
<li>在 IDE 中可以忽略<code>public abstract</code>默认的关键字，直接以<code>返回类型 方法名</code>的形式进行声明。</li>
</ul>
</li>
<li>属性:<code>public static final</code><ul>
<li>默认成为常量（不推荐）</li>
</ul>
</li>
<li>接口不能被实例化，接口中没有构造方法</li>
<li>利用<code>implements</code>可以实现多个接口</li>
</ul>
</li>
</ol>
<p><code>UserService.java</code> ——接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface 定义接口的关键字  接口毒需要有实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 接口中的所有定义其实都是抽象的 public abstract</span></span><br><span class="line">    <span class="comment">// idea默认会将其隐视起来</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TimeService.java</code>——接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">timer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserServicelmpl.java</code>——类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类可以实现接口 implements接口</span></span><br><span class="line"><span class="comment">// 实现了接口的类，就需要重写接口中的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用接口实现了多继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>,<span class="title">TimeService</span></span>&#123;</span><br><span class="line">	<span class="comment">// 重写接口中的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Interface-VS-Abstract-Calss"><a href="#3-Interface-VS-Abstract-Calss" class="headerlink" title="3. Interface VS Abstract Calss"></a>3. <code>Interface</code> <em>VS</em> <code>Abstract Calss</code></h3><ol>
<li>相同点<ol>
<li>都不能被实例化</li>
<li><strong><em>接口的实现类</em> 和 <em>抽象类的子类</em> 只有全部实现了接口或者抽象类中的方法后才可以被实例化。</strong></li>
</ol>
</li>
<li>不同点<ol>
<li>接口只能定义抽象方法不能实现方法，抽象类既可以定义抽闲方法，也可以实现方法。</li>
<li>但继承，多实现。接口可以实现</li>
<li>接口强调的是功能，抽象类强调的是所属关系。</li>
<li>接口中<strong>所有的成员变量</strong>为 <code>public static final</code>, 静态不可修改，必须初始化。接口中的<strong>所有方法</strong>都是<code>public abstract</code>公开抽象的，而且不能有构造方法。抽象类比较自由，和普通的类差不多，可以有抽象方法，也可以没有抽象方法，可以有正常的方法，也可以没有正常的方法。</li>
</ol>
</li>
</ol>
<p><a href="https://blog.csdn.net/qq_44628595/article/details/117350096" target="_blank" rel="noopener">参考文献: https://www.jianshu.com/p/c4f023d02f0c</a></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Neary Li</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="../../../../tags/Java/"># Java</a>
                    
                        <a href="../../../../tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"># 抽象类</a>
                    
                        <a href="../../../../tags/%E6%8E%A5%E5%8F%A3/"># 接口</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="../Java-%E7%BA%BF%E7%A8%8B/">Java_线程</a>
            
            
            <a class="next" rel="next" href="../Java-%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/">Java_封装、继承、多态</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">


    <div class="copyright">
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>    <span id="busuanzi_container_site_pv">
                    总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
            <span id="busuanzi_container_site_uv">
                    总访客数<span id="busuanzi_value_site_uv"></span>人
            </span> 
            <br>
        <span>copyright &copy 2021 Neary Li. All rights reserved.</span>
    </div>
    
</footer>

    </div>
</body>
</html>
